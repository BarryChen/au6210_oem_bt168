C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SYS_ON_OFF
OBJECT MODULE PLACED IN .\output\obj\sys_on_off.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE system\sys_on_off.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE INCDIR(.\c
                    -onfig;.\device;.\display;.\fs;.\key;.\lib_if;.\play;.\system;.\library;.\power;.\radio;.\eeprom;.\spi_flash;.\slave;.\bl
                    -uetooth;.\i2c) DEBUG PRINT(.\output\lst\sys_on_off.lst) OBJECT(.\output\obj\sys_on_off.obj)

line level    source

   1          #include "syscfg.h"
   2          #include "key.h"
   3          #include "utility.h"
   4          #include "user_interface.h"
   5          #include "power.h"
   6          #include "chip.h"
   7          #include "ir.h"
   8          #include "radio_ctrl.h"
   9          #include "debug.h"
  10          #include "display.h"
  11          #include "bluetooth_ctrl.h"
  12          #include "npca110x.h"
  13          
  14          
  15          BYTE XDATA gWakeupTrigFlg _at_ 0x06D8; //²»ÒªÇáÒ×¸Ä¶¯µØÖ·
  16          
  17          
  18          //ÏµÍ³Æô¶¯£¬°üÀ¨ÏµÍ³´ÓSLEEP×´Ì¬ÏÂ»½ÐÑÆô¶¯»òÕß´ÓPOWER DOWN×´Ì¬ÏÂÒÔÆ¬ÄÚÖ÷µçÔ´ÉÏµç·½Ê½Æô¶¯µÄÏà¹Ø´¦Àí
  19          //Ò»°ãÇé¿öÏÂ£¬2ÖÖÆô¶¯·½Ê½ÔÚÓÃ»§²úÆ·ÖÐ²»»áÍ¬Ê±´æÔÚ
  20          VOID SystemOn(VOID)
  21          {
  22   1              TIMER   WaitTimer;
  23   1      
  24   1              DBG1(("*******SystemOn************\n"));
  25   1              
  26   1      
  27   1      #if (POWER_SAVING_MODE_OPTION == POWER_SAVING_MODE_SLEEP)
                      
                      //»ñµÃ´ÓSLEEP×´Ì¬»½ÐÑµÄ´¥·¢Ô´±êÖ¾
                      DBG1((">>WakeUpOp(), gWakeupTrigFlg:%bx\n", gWakeupTrigFlg));
              
                      //ÏµÍ³¶¨ÒåÁËIR»½ÐÑ¹¦ÄÜ£¬IR½ÓÊÕÍ·Á¬½ÓÓÚGPIOB6/GPIOE0£¬IRÐÅºÅ»½ÐÑÏµÍ³ºó£¬ÔòÅÐ¶Ï¼üÖµ
              #ifdef  WIS_FLG_IR
                      if((gWakeupTrigFlg == WIS_FLG_GPB6) || (gWakeupTrigFlg == WIS_FLG_GPE0))
                      {               
                              DWORD IrKeyData;
                              
              
                              TimeOutSet(&WaitTimer, 3500);
                              //Èç¹ûÔÚ¹æ¶¨Ê±¼äÄÚÎ´·¢ÏÖÔ¤¶¨µÄIR¼üÖµ£¬Ôò¼ÌÐøË¯Ãß
                              while(!IsTimeOut(&WaitTimer))   
                              {
              #ifdef FUNC_WATCHDOG_EN
                                      FeedWatchDog();
              #endif
                                      IrKeyData = IrKeyDataVal();
                                      DBG1(("IrKeyData = : %08LX\n", IrKeyData)); 
              
                                      //Èç¹û¼ì²âµ½Ô¤¶¨µÄIR¼üÖµ£¬Ôò¿ªÊ¼ÔËÐÐÏµÍ³
                                      if( (IrKeyData == 0x5AA57F80) ||
                                              (IrKeyData == 0x5FA07F80) ||
                                              (IrKeyData == 0x5EA17F80) ||
                                              (IrKeyData == 0x5DA27F80) ||
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 2   

                                              (IrKeyData == 0x5CA37F80) ||
                                              (IrKeyData == 0x59A67F80) ||
                                              (IrKeyData == 0x5BA47F80) )
                                      {
                                              MessageInit();
                                              DBG1(("WAKE UP FROM SLEEP BY IR!\n"));
                                              baGPIOCtrl[GPIO_A_IE] &= ~0x40;//A2
                                              return;
                                      }
                                      else
                                      {
                                              DBG1(("ERROR IR KEY!\n"));
                                              break;
                                      }
                              }
                              
                              DBG1(("TIMEOUT!\n"));
              #ifdef IR_KEY_PORT
                              if(IR_KEY_PORT == IR_INPUT_GPIOB6)
                              {
                                      SetWakeupSrcInSleep(WIS_GPB6_LOW);
                                      DBG1(("*GPIO_B_IN:%bx\n", GetGpioReg(GPIO_B_IN)));
                                      while((GetGpioReg(GPIO_B_IN) & 0x40) != 0x40)
                                      {
                                              DBG1(("ÇëÈ·±£½øÈëSleep×´Ì¬Ç°WakeUpÌõ¼þ²»³ÉÁ¢£¡(GPIO_C_IN:%bx(GPIOC3 shoule be 0))\n", GetGpioReg(GPIO_
             -B_IN)));
                                              WaitMs(10);
              #ifdef FUNC_WATCHDOG_EN
                                              FeedWatchDog();
              #endif
                                      }
                              }
                              else if(IR_KEY_PORT == IR_INPUT_GPIOE0)
                              {
                                      SetWakeupSrcInSleep(WIS_GPE0_LOW);
                                      DBG(("*GPIO_E_IN:%bx\n", GetGpioReg(GPIO_E_IN)));
                                      while((GetGpioReg(GPIO_E_IN) & 0x01) != 0x01)
                                      {
                                              DBG1(("ÇëÈ·±£½øÈëSleep×´Ì¬Ç°WakeUpÌõ¼þ²»³ÉÁ¢£¡(GPIO_C_IN:%bx(GPIOC3 shoule be 0))\n", GetGpioReg(GPIO_
             -B_IN)));
                                              WaitMs(10);
              #ifdef FUNC_WATCHDOG_EN
                                      FeedWatchDog();
              #endif
                                      }
                              }
              #endif
              
                              GoToSleepMode(SLEEP_MOD_OTP_PD);
              
                              DBG1(("<<WakeUpOp()\n")); 
                              return;
                      }
              
                      
              #endif
                      
              
              #elif (POWER_SAVING_MODE_OPTION == POWER_SAVING_MODE_POWERDOWN)
 111   1      #if     (PWR_KEY_MODE == PWR_KEY_PUSH_BUTTON)
 112   1              DBG(("\nPWR_KEY_PUSH_BUTTON\n\n"));     
 113   1              SetChip8SRstMode(CRM_IN_PUSH_BUTTON);
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 3   

 114   1      
 115   1      #elif(PWR_KEY_MODE == PWR_KEY_SLIDE_SWITCH)
                      DBG(("\nPWR_KEY_SLIDE_SWITCH\n\n"));    
                      SetChip8SRstMode(CRM_IN_SLIDE_SWITCH);
              #endif
 119   1      
 120   1              gWakeupTrigFlg = GetWakeupFlgFromPD();                  //»ñµÃ´Ópowerdown×´Ì¬´¥·¢Æ¬ÄÚÖ÷µçÔ´ÉÏµçÏµÍ³Æô¶¯µÄ´¥·¢Ô´±êÖ¾
 121   1              DBG(("gWakeupTrigFlg:%bx\n", gWakeupTrigFlg));
 122   1      
 123   1              if(WIP_SRC_PWR_KEY & gWakeupTrigFlg)
 124   1              {
 125   2                      DBG(("POWER KEY SYS ON\n"));
 126   2              }
 127   1              else if(WIP_SRC_LP_RTC & gWakeupTrigFlg)
 128   1              {
 129   2                      DBG(("LP_RTC SYS ON\n"));
 130   2              }
 131   1      
 132   1              //Èç¹ûPOWER_KEYÊ¹ÓÃÈí¿ª¹Ø(push button)£¬²¢ÇÒ¶¨ÒåÁËPOWER KEY¿ª¹Ø»ú±£³ÖÊ±¼ä
 133   1              //ÀýÈç£¬ÒªÇó°´×¡POWER_KEY³¬¹ý2Ãëºó£¬ÏµÍ³²Å»áµãÁÁÏÔÊ¾¼ÌÐøÔËÐÐ£¬·ñÔòÏµÍ³ÔÙ´Î¹Ø±Õ£¬ÓÃ»§²»»á¸Ð¾õµ½ÏµÍ³ÔËÐÐ¹ý
 134   1              //POWER_KEY³ÖÐø°´ÏÂÁË¹æ¶¨Ê±¼äµÄÅÐ¶¨ÊÇÔÚpower_key.cÄÚÍê³ÉµÄ¡£
 135   1      #if     ((PWR_KEY_MODE == PWR_KEY_PUSH_BUTTON) && defined(TIME_POWER_ON_HOLD))  
 136   1              if(WIP_SRC_PWR_KEY & gWakeupTrigFlg)            //±ØÐëÊÇPOWER_KEY»½ÐÑÏµÍ³Ê±£¬²Å¼ì²é¿ª»ú±£³ÖÊ±¼ä£¬¶øWTD¸´Î»µÈÏµÍ³ÖØÐ
             -ÂÆô¶¯Ôò²»ÐèÒª
 137   1              {
 138   2                      TimeOutSet(&WaitTimer, (TIME_POWER_ON_HOLD * 2));
 139   2                      
 140   2                      while(!IsTimeOut(&WaitTimer))
 141   2                      {
 142   3      #ifdef FUNC_WATCHDOG_EN
 143   3                              FeedWatchDog();
 144   3      #endif
 145   3                              KeyEventGet();  
 146   3      
 147   3                              if(MessageGet(MSG_FIFO_KEY) == MSG_SYS_ON)              //Èç¹û´ïµ½¿ª»ú±£³ÖÊ±¼ä£¬ÔòÏµÍ³¼ÌÐøÔËÐÐ
 148   3                              {                       
 149   4                                      MessageInit();
 150   4                                      DBG(("POWER_KEY Hold time,MSG_SYS_ON\n"));
 151   4                                      return;
 152   4                              }
 153   3                      }
 154   2                      
 155   2                      DBG(("TIMEOUT!\n"));
 156   2                      //Èç¹ûÔÚ¹æ¶¨Ê±¼äÄÚÃ»ÓÐÊÕµ½ÓÉpower_key.cÍÆËÍµÄMSG_SYS_ONÏûÏ¢£¬ÐèÒªÔÙ´ÎÏµÍ³¹Ø±Õ¡£
 157   2                      GoToPDMode();
 158   2              }
 159   1      
 160   1      #elif(PWR_KEY_MODE == PWR_KEY_SLIDE_SWITCH)
                      DBG(("\nPWR_KEY_MODE == PWR_KEY_SLIDE_SWITCH\n\n"));    
              #endif          
 163   1                      
 164   1      #endif
 165   1      }
 166          
 167          
 168          //ÏµÍ³¹Ø±Õ£¬°üÀ¨ÏµÍ³ÒÔSLEEP·½Ê½¹Ø±Õ»òÕßÒÔÆ¬ÄÚÖ÷µçÔ´ÏÂµçPOWER DOWN·½Ê½¹Ø±ÕµÄÏà¹Ø´¦Àí
 169          VOID SystemOff(VOID)
 170          {
 171   1      #if (POWER_SAVING_MODE_OPTION == POWER_SAVING_MODE_SLEEP)
                      //ÐÝÃß£¬½øÈëSLEEPÄ£Ê½
                      DBG(("SLEEP!\n"));
              #ifdef FUNC_DISP_EN
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 4   

                      DispDeInit();
              #endif
              
              #ifdef FUNC_RADIO_EN
                      if(gSys.SystemMode == SYS_MODE_RADIO)
                      {
                              RadioCtrlDeinit();
                      }
              #endif
              
                      MuteOn(FALSE, TRUE);
                      //NPCA110X_SetOutMute(TRUE);
                      InDacChannelSel(DAC_CH_NONE);
                      InDacPowerDown(FALSE);
              
                      //ºìÍâ»½ÐÑÔ´Ñ¡ÔñÊ±ÐèÒª×¢ÒâÑ¡ÔñµÄGPIO¶Ë¿Ú
                      SetWakeupSrcInSleep(WIS_GPB6_LOW);
                      //SetWakeupSrcInSleep(WIS_GPD7_HIGH);
                      //SetWakeupSrcInSleep(WIS_GPE0_LOW);
                      //SetWakeupSrcInSleep(WIS_GPE1_HIGH);
                      //SetWakeupSrcInSleep(WIS_RTC_ALARM);
                      //SetWakeupSrcInSleep(WIS_PWR_KEY); 
                      GoToSleepMode(SLEEP_MOD_OTP_PD);
                      //GoToSleepMode(SLEEP_MOD_NORMAL);
                      return;
              
              #elif (POWER_SAVING_MODE_OPTION == POWER_SAVING_MODE_POWERDOWN)
 202   1      
 203   1      #if(PWR_KEY_MODE == PWR_KEY_PUSH_BUTTON) //POWER_KEYÎª°´Å¥¿ª¹Ø£¨Èí¿ª¹Ø£©
 204   1              DBG(("\nSYSTEM OFF BY PUSH BUTTON!\n\n"));
 205   1      
 206   1      #ifdef  FUNC_ALARM_EN
                      SetWakeupLpRtcInPD(); // RTCÄÖÖÓ»½ÐÑÊ¹ÄÜ
              #endif
 209   1      
 210   1      #elif(PWR_KEY_MODE == PWR_KEY_SLIDE_SWITCH)
                              DBG(("\nSYSTEM OFF BY SLID SWITCH!\n\n"));      
              #endif
 213   1              
 214   1      #ifdef FUNC_DISP_EN
 215   1              DispDeInit();
 216   1      #endif
 217   1      
 218   1              MuteOn(FALSE, TRUE);
 219   1      //Ö´ÐÐInDacMuteEn¡¢InDacChannelSelºÍInDacPowerDown ¹²800ms×óÓÒ£¬Ôì³É¹Ø»úºó²»ÄÜ¿ìËÙ°´¼ü¿ª»ú
 220   1      //ÆÁ±ÎÕâ²¿·Ö´úÂëºó¿ÉÄÜµ¼ÖÂ¿ìËÙ¿ª»ú»áÓÐPOPÉù
 221   1      //      InDacChannelSel(DAC_CH_NONE);
 222   1      //      InDacPowerDown(FALSE);
 223   1              
 224   1              GoToPDMode();   
 225   1      #endif
 226   1      }
 227          
 228          
 229          #ifdef FUN_SYSTEM_POWEROFF_WAIT_TIME
              SystemTimingOff gSysTimeOffState;
              
              
              VOID SystemOffTimeInit(VOID)
              {
                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_IDLE;
                      gSysTimeOffState.EnState = FALSE;
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 5   

                      gSysTimeOffState.SleepState = SLEEP_00;
              }
              
              
              static VOID SystemOffSetTimer(VOID)
              {
                      DWORD SysOffWaitTime;
              
                      switch(gSysTimeOffState.SleepState)
                      {       
                              case SLEEP_15:
                                      SysOffWaitTime = 900000;
                                      break;
                                      
                              case SLEEP_30:
                                      SysOffWaitTime = 1800000;
                                      break;
              
                              case SLEEP_45:
                                      SysOffWaitTime = 2700000;
                                      break;
                                      
                              case SLEEP_60:
                                      SysOffWaitTime = 3600000;
                                      break;
                                      
                              case SLEEP_75:
                                      SysOffWaitTime = 4500000;
                                      break;  
                                      
                              case SLEEP_90:
                                      SysOffWaitTime = 5400000;
                                      break;
              
                              case SLEEP_105:
                                      SysOffWaitTime = 6300000;
                                      break;
                                      
                              case SLEEP_120:
                                      SysOffWaitTime = 7200000;
                                      break;
                                      
                              default:
                                      break;
                      }
                      
                      TimeOutSet(&gSysTimeOffState.AutoOutTimer, SysOffWaitTime);     
                      DBG(("Start....                                          %2BX\n",gSysTimeOffState.SleepState));
              }
              
              
              VOID SystemOffTimeEnDis(BYTE Type)
              {
                      TimeOutSet(&gSysTimeOffState.DisTimer, 3000);
                              
                      if(SYSOFF_TIME_SET_VALUE == Type)
                      {
                              if(gSysTimeOffState.EnState == FALSE)
                              {
                                      gSysTimeOffState.EnState = TRUE;                                
                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_SET_MODE_VALID;     
                                      SystemOffSetTimer();
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 6   

                              }
                              else
                              {                               
                                      gSysTimeOffState.EnState = FALSE;               
                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_SET_DIS;
                              }       
                      }
                      else if(SYSOFF_TIME_READ_ONLY == Type)
                      {               
                              if((gSysTimeOffState.ProState == SYS_OFF_TIMEING_WAIT_POWEROFF) || (gSysTimeOffState.ProState == SYS_OFF
             -_TIMEING_SET_MODE_VALID))                     
                              {
                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_READ_ONLY_TIMING;//»Øµ½¶¨Ê±¹Ø»ú»òÉèÖÃ¶¨Ê±¹Ø»ú×´Ì¬
                              }       
                              else
                              {
                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_READ_ONLY_IDLE;//»Øµ½¿ÕÏÐ×´Ì¬               
                              }
                      }
              }
              
              
              VOID SystemOffTimeSet(VOID)
              {                               
                      TimeOutSet(&gSysTimeOffState.DisTimer, 3000);   
              
                      gSysTimeOffState.SleepState++;
                      if(gSysTimeOffState.SleepState >= SLEEP_MAX)
                      {
                              gSysTimeOffState.SleepState = SLEEP_00;
                      }       
                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_SET_MODE_VALID;     
                      
                      if(gSysTimeOffState.SleepState != SLEEP_00)
                      {
                              gSysTimeOffState.EnState = TRUE;
                              SystemOffSetTimer();
                      }
                      else
                      {
                              gSysTimeOffState.EnState = FALSE;
                      }       
              
              //      if(gSysTimeOffState.EnState == TRUE)
              //      {
              //              gSysTimeOffState.SleepState++;
              //              if(gSysTimeOffState.SleepState >= SLEEP_MAX)
              //              {
              //                      gSysTimeOffState.SleepState = SLEEP_00;
              //              }       
              //              SystemOffSetTimer();
              //              gSysTimeOffState.ProState = SYS_OFF_TIMEING_SET_MODE_VALID;     
              //      }
              //      else
              //      {
              //              gSysTimeOffState.ProState  = SYS_OFF_TIMEING_SET_MODE_INVALID;
              //      }
              }
              
              
              //Èç¹ûÓÐºÍ´Ëº¯ÊýÀàËÆÓÃ·¨(Ç¶Èëµ½¸÷¸öÄ£Ê½)µÄº¯ÊýÎ»ÓÚÆäºó£¬´Ëº¯Êý²»ÒªÓÐdefault£¬·ÀÖ¹À¹½ØºóÕßÓÐÓÃµÄÏûÏ¢
              VOID SystemOffTimeMsgPro(BYTE Msg)
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 7   

              {       
                      if(Msg != MSG_NONE)
                      {
                              TimeOutSet(&gSysTimeOffState.DisTimer, 0);      
                      }
                      
                      switch(Msg)
                      {
                              case MSG_SLEEP:
                                      SystemOffTimeSet();
                                      break;          
                                      
              //              case MSG_SYS_TIMING_EN:
              //                      SystemOffTimeEnDis(SYSOFF_TIME_SET_VALUE);
              //                      break;
              
              //              case MSG_SYS_TIMING_SET:
              //                      SystemOffTimeSet();
              //                      break;
              
              //              case MSG_SYS_TIMING_READ:       
              //                      SystemOffTimeEnDis(SYSOFF_TIME_READ_ONLY);
              //                      break;          
              
                              default:
                                      break;
                      }
              }
              
              
              VOID SystemOffTimeWait(VOID)
              {
                      switch(gSysTimeOffState.ProState)
                      {
                              case SYS_OFF_TIMEING_IDLE:
                                      break;
              
                              case SYS_OFF_TIMEING_READ_ONLY_IDLE:
                              case SYS_OFF_TIMEING_READ_ONLY_TIMING:
                              case SYS_OFF_TIMEING_SET_DIS:
                              case SYS_OFF_TIMEING_SET_MODE_VALID:
                              case SYS_OFF_TIMEING_SET_MODE_INVALID:
                                      if(IsTimeOut(&gSysTimeOffState.DisTimer))
                                      {
                                              if((gSysTimeOffState.ProState == SYS_OFF_TIMEING_SET_MODE_VALID) || (gSysTimeOffState.ProState == SYS_
             -OFF_TIMEING_READ_ONLY_TIMING))
                                              {
                                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_WAIT_POWEROFF;
                                              }
                                              else
                                              {
                                                      gSysTimeOffState.ProState = SYS_OFF_TIMEING_IDLE;
                                              }
                                      }
                                      break;
              
                              case SYS_OFF_TIMEING_WAIT_POWEROFF:
                                      if(IsTimeOut(&gSysTimeOffState.AutoOutTimer))
                                      {
                                              if(gSysTimeOffState.EnState == TRUE)
                                              {
                                                      DBG(("SYSTEM OFF BY TimeOut!\n"));
C51 COMPILER V9.00   SYS_ON_OFF                                                            11/22/2015 18:52:03 PAGE 8   

                                                      SystemOff();
                                              }
                                      }
                                      break;
                                      
                              default:
                                      break;                                  
                      }
              }
              
              #endif
 432          
 433          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     94    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
