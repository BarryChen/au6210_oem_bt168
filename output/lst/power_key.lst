C51 COMPILER V9.00   POWER_KEY                                                             12/30/2015 18:11:23 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE POWER_KEY
OBJECT MODULE PLACED IN .\output\obj\power_key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE key\power_key.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE INCDIR(.\confi
                    -g;.\device;.\display;.\fs;.\key;.\lib_if;.\play;.\system;.\library;.\power;.\radio;.\eeprom;.\spi_flash;.\slave;.\blueto
                    -oth;.\i2c) DEBUG PRINT(.\output\lst\power_key.lst) OBJECT(.\output\obj\power_key.obj)

line level    source

   1          #include <reg51.h>      
   2          
   3          #include "type.h"       
   4          #include "syscfg.h"
   5          #include "utility.h"
   6          #include "debug.h"
   7          #include "timer.h"
   8          #include "sysctrl.h"
   9          #include "key.h"
  10          #include "power_key.h"
  11          #include "bt.h"
  12          
  13          
  14          #if     (PWR_KEY_MODE == PWR_KEY_PUSH_BUTTON)
  15          
  16                  #warning        "MV: PUSH BUTTON POWER KEY ENABLE!"
*** WARNING C320 IN LINE 16 OF key\power_key.c: "MV: PUSH BUTTON POWER KEY ENABLE!"
  17          
  18          extern BOOL     gIsPwrkeyPadOn;                         //POWER_KEY引脚的状态判定是在定时中断内执行的，通过该全局变量与本文件的软开
             -关处理流程交互
  19                                                                                          //系统启动时POWER_KEY默认是接通状态
  20          #define         POWER_KEY_CP_TIME                       100                     //要求轻触开关机时，CP时间需要短
  21          #define         POWER_KEY_CPH_TIME                      100
  22          
  23          
  24          typedef enum _POWER_KEY_STATE
  25          {
  26                  POWER_KEY_STATE_IDLE,
  27                  POWER_KEY_STATE_PRESS_DOWN,
  28                  POWER_KEY_STATE_CP
  29          
  30          } POWER_KEY_STATE;
  31          
  32          
  33          TIMER                   PowerKeyWaitTimer;
  34          POWER_KEY_STATE PowerKeyState;
  35          BOOL                    IsPwrkeyInSysOn = TRUE;         //表示当前是否是系统启动阶段的POWER_KEY识别
  36          
  37          #ifdef AU6210K_XLX_ALD800
              static CODE BYTE PowerKeyEvent[3] = {MSG_MODE_SW, MSG_SYS_ON, MSG_SYS_OFF};     
              #else
  40          static CODE BYTE PowerKeyEvent[3] = {MSG_NONE, MSG_SYS_ON, MSG_SYS_OFF};        
  41          #endif
  42          
  43          
  44          
  45          // Initialize POWER_KEY scan operation.
  46          VOID PowerKeyScanInit(VOID)
  47          {
  48   1              DBG(("PowerKeyScanInit*******\n"));
  49   1              PowerKeyState = POWER_KEY_STATE_IDLE;
  50   1              IsPwrkeyInSysOn = TRUE;                                 //首先软开关用于系统启动，此后用于系统关闭
  51   1      }
C51 COMPILER V9.00   POWER_KEY                                                             12/30/2015 18:11:23 PAGE 2   

  52          
  53          extern BOOL BtPowerIsOn;
  54          //
  55          // POWER_KEY与普通的按键不同，连接按钮开关（软开关）时的主要作用还是系统开关机，当然，也允许复用短按功能。
  56          // 短按产生时，推送短按消息。超过短按区间，推送系统开关机消息。
  57          MESSAGE PowerKeyEventGet(VOID)                                                  
  58          {
  59   1              //DBG(("PowerKeyEventGet*******\n"));
  60   1              //DBG(("PowerKeyState:%bx\n", PowerKeyState));
  61   1              //DBG(("gIsPwrkeyPadOn:%bx\n", gIsPwrkeyPadOn));
  62   1              switch(PowerKeyState)
  63   1              {
  64   2                      case POWER_KEY_STATE_IDLE:
  65   2                              if(gIsPwrkeyPadOn == FALSE)
  66   2                              {
  67   3                                      IsPwrkeyInSysOn = FALSE;
  68   3                                      if(BtPowerIsOn)
  69   3                                      {
  70   4                                              baGPIOCtrl[GPIO_D_OUT] &= ~0x20; //D5
  71   4                                      }
  72   3                                      return MSG_NONE;
  73   3                              }
  74   2                              DBG(("GOTO POWER PRESS DOWN!\n"));
  75   2      
  76   2      #if defined(TIME_POWER_ON_HOLD)
  77   2                              if(IsPwrkeyInSysOn == TRUE)
  78   2                              {
  79   3                                      TimeOutSet(&PowerKeyWaitTimer, TIME_POWER_ON_HOLD);     
  80   3                              }
  81   2                              else
  82   2      #endif
  83   2                              {
  84   3                                      TimeOutSet(&PowerKeyWaitTimer, TIME_POWER_OFF_HOLD);
  85   3                              }
  86   2      
  87   2                              if(BtPowerIsOn)
  88   2                              {
  89   3                                      if(GET_BT_CALL_STATUS() || (gSys.SystemMode == SYS_MODE_BLUETOOTH))
  90   3                                              baGPIOCtrl[GPIO_D_OUT] |= 0x20; //D5
  91   3                              }
  92   2      
  93   2                              PowerKeyState = POWER_KEY_STATE_PRESS_DOWN;
  94   2                              break;
  95   2      
  96   2                      case POWER_KEY_STATE_PRESS_DOWN:
  97   2                              if(gIsPwrkeyPadOn == FALSE)
  98   2                              {
  99   3                                      IsPwrkeyInSysOn = FALSE;
 100   3                                      PowerKeyState = POWER_KEY_STATE_IDLE;
 101   3                                      if(BtPowerIsOn)
 102   3                                      {
 103   4                                              baGPIOCtrl[GPIO_D_OUT] &= ~0x20; //D5
 104   4                                      }
 105   3                                      
 106   3                                      return PowerKeyEvent[0];                        //return key sp value
 107   3                              }
 108   2                              else if(IsTimeOut(&PowerKeyWaitTimer))
 109   2                              {
 110   3                                      TimeOutSet(&PowerKeyWaitTimer, POWER_KEY_CPH_TIME);
 111   3                                      PowerKeyState = POWER_KEY_STATE_CP;
 112   3                                      if(IsPwrkeyInSysOn == TRUE)                     //系统启动时，推送MSG_SYS_ON消息，用于通知POWER_KEY开机保持时间已到
 113   3                                      {
C51 COMPILER V9.00   POWER_KEY                                                             12/30/2015 18:11:23 PAGE 3   

 114   4                                              DBG(("PowerKeyEvent[1]:%bx\n", PowerKeyEvent[1]));
 115   4                                              return PowerKeyEvent[1];
 116   4                                      }
 117   3                                      else                                                            //系统启动之后，POWER_KEY的长按只发送MSG_SYS_OFF消息，用于关闭系统
 118   3                                      {
 119   4                                              DBG(("PowerKeyEvent[2]:%bx\n", PowerKeyEvent[2]));
 120   4                                              return PowerKeyEvent[2];
 121   4                                      }
 122   3                              }
 123   2                              break;
 124   2                              
 125   2                      case POWER_KEY_STATE_CP:
 126   2                              if(gIsPwrkeyPadOn == FALSE)
 127   2                              {
 128   3                                      IsPwrkeyInSysOn = FALSE;                        //系统启动后，POWER_KEY长按的作用变为关机
 129   3                                      PowerKeyState = POWER_KEY_STATE_IDLE;
 130   3                              }
 131   2                              else if(IsTimeOut(&PowerKeyWaitTimer))
 132   2                              {
 133   3                                      TimeOutSet(&PowerKeyWaitTimer, POWER_KEY_CPH_TIME);
 134   3                                      if(IsPwrkeyInSysOn == FALSE)            //系统启动后，POWER_KEY的长按只发送MSG_SYS_OFF消息，用于关闭系统
 135   3                                      {
 136   4                                              DBG(("PowerKeyEvent[2]:%bx\n", PowerKeyEvent[2]));
 137   4                                              return PowerKeyEvent[2];
 138   4                                      }
 139   3                              }
 140   2                              break;  
 141   2                                              
 142   2                      default:
 143   2                              PowerKeyState = POWER_KEY_STATE_IDLE;
 144   2                              break;
 145   2              }
 146   1              return MSG_NONE;
 147   1      }
 148          
 149          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    309    ----
   CONSTANT SIZE    =      3    ----
   XDATA SIZE       =      7    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
