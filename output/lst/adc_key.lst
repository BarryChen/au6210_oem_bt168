C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADC_KEY
OBJECT MODULE PLACED IN .\output\obj\adc_key.obj
COMPILER INVOKED BY: d:\Keil\C51\BIN\C51.EXE key\adc_key.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE INCDIR(.\config;
                    -.\device;.\display;.\fs;.\key;.\lib_if;.\play;.\system;.\library;.\power;.\radio;.\eeprom;.\spi_flash;.\slave;.\bluetoot
                    -h;.\i2c) DEBUG PRINT(.\output\lst\adc_key.lst) OBJECT(.\output\obj\adc_key.obj)

line level    source

   1          #include <reg51.h>                                                                              //include public header files
   2          
   3          #include "type.h"                                                                               //include project header files
   4          #include "syscfg.h"
   5          #include "utility.h"
   6          #include "debug.h"
   7          #include "timer.h"
   8          #include "sysctrl.h"
   9          #include "key.h"
  10          #include "adc_key.h"
  11          #include "gpio.h"
  12          #include "adc.h"
  13          #include "message.h"
  14          #include "device.h"
  15          #include "seg_panel.h"
  16          #include "seg_led_disp.h"
  17          
  18          
  19          #ifdef FUNC_ADC_KEY_EN
  20          
  21          #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              #define         ADC_KEY_SCAN_TIME                       20
              #define         ADC_KEY_JTTER_TIME                      40
              #else
  25          #define         ADC_KEY_SCAN_TIME                       10
  26          #define         ADC_KEY_JTTER_TIME                      20
  27          #endif
  28          #define         ADC_KEY_CP_TIME                         600     //1000
  29          #define         ADC_KEY_PWRDOWN_CP_TIME         2000    //cp-time for power-down key
  30          #define         ADC_KEY_CPH_TIME                        200             //450
  31          #define         ADC_KEY_HPPUSHOUT_CP_TIME       200
  32          
  33          //#define               ADC_KEY_COUNT                           11
  34          
  35          #define         ADC_KEY_POWER0_IDX                      8               //POWER-DOWN KEY index.
  36          #define         ADC_KEY_POWER1_IDX                      15              //POWER-DOWN KEY index.
  37          #define         ADC_KEY_POWER2_IDX                      20
  38          
  39          #ifdef HEADPHONE_ADC_PORT_CH
              #ifdef HEADPHONE_ADC_PU_EN
              #define         ADC_KEY_HPPUSHOUT_IDX           23
              #define         ADC_KEY_HPPUSHIN_IDX            22
              #else
              #define         ADC_KEY_HPPUSHOUT_IDX           22
              #define         ADC_KEY_HPPUSHIN_IDX            23
              #endif
              #endif
  48          
  49          typedef enum _ADC_KEY_STATE
  50          {
  51                  ADC_KEY_STATE_IDLE,
  52                  ADC_KEY_STATE_JITTER,
  53                  ADC_KEY_STATE_PRESS_DOWN,
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 2   

  54                  ADC_KEY_STATE_CP
  55          
  56          } ADC_KEY_STATE;
  57          
  58          TIMER                   AdcKeyWaitTimer;
  59          TIMER                   AdcKeyScanTimer;
  60          ADC_KEY_STATE   AdcKeyState;
  61          
  62          
  63          #ifdef FUNC_BEEP_SOUND_EN       
              extern BOOL gPushKeyNeedBeepFlag;
              #endif
  66          
  67          #ifdef FUNC_SEG_LED_EN
              extern BOOL gLedDispRefreshFlag;
              #endif
  70          
  71          #if defined(AU6210K_JLH_JH82B)
              #define         ADC_KEY_COUNT                           3
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR     
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,    MSG_NONE        },      //SW2   
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,    MSG_NONE        },      //SW3
                      {MSG_PLAY_PAUSE,        MSG_MODE_SW,            MSG_NONE,               MSG_NONE        },      //SW1
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
              #if 1                   //上拉10K
                      4,      //SW3   0               0       0       //SW13
                      17,     //SW4   1.5k            8       8       //SW14
                      30,     //SW5   6.8K            26      26      //SW15
              #else
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
              #endif
              };
              
              #elif defined(AU6210K_NR_D_9X)
              #define         ADC_KEY_COUNT                           3
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR     
                      {MSG_PLAY_PAUSE,                MSG_NONE,                       MSG_NONE,               MSG_NONE        },      //SW4
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,    MSG_NONE        },      //SW3
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,    MSG_NONE        },      //SW2   
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
              };
              
              /*#elif defined(AU6210K_NR_D_9X_XJ_HTS)
              #define         ADC_KEY_COUNT                           3
              static CODE BYTE AdcKeyEvent[][4] = 
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 3   

              {
              //      SP                                              CPS                                     CPH                                     CPR     
                      {MSG_PLAY_PAUSE,        MSG_BLUETOOTH_REJECT,                   MSG_NONE,               MSG_NONE        },      //SW4
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,    MSG_NONE        },      //SW2   
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,    MSG_NONE        },      //SW3
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
              };*/
              #elif defined(AU6210K_NR_D_9X_XJ_HTS)
              #define         ADC_KEY_COUNT                           5
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR     
                      {MSG_VOL_SUB,       MSG_NONE,                       MSG_NONE,                   MSG_NONE                },      //SW1   
                      {MSG_NEXT,                      MSG_MODE_SW,                MSG_NONE,               MSG_NONE            },      //SW2   
                      {MSG_PRE,                       MSG_BT_DISCONNECT,                      MSG_NONE,                   MSG_NONE            },      //SW3
                      {MSG_PLAY_PAUSE,        MSG_BLUETOOTH_REJECT,   MSG_NONE,                       MSG_NONE                }, //SW4
                      {MSG_VOL_ADD,           MSG_NONE,                           MSG_NONE,                   MSG_NONE                },      //SW5
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
                      25,     //SW7   12K             22      22      //SW17
              };
              
              #elif defined(AU6210K_HXX_B002)
              #define         ADC_KEY_COUNT                           5
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR     
                      {MSG_PLAY_PAUSE,                MSG_SCAN,                       MSG_NONE,               MSG_NONE        },      //SW4
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,    MSG_NONE        },      //SW3
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,    MSG_NONE        },      //SW2   
                      {MSG_MODE_SW,   MSG_NONE,               MSG_NONE,               MSG_NONE        },      //SW1
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
              };
              
              #elif defined(AU6210K_NR_D_8_CSRBT)
              #define         ADC_KEY_COUNT                           8
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                                     CPR     
                      {MSG_DEFAULT,           MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW1
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 4   

                      {MSG_NEXT,                      MSG_VOL_ADD,                    MSG_VOL_ADD,                            MSG_NONE        },      //SW3
                      {MSG_PRE,                       MSG_VOL_SUB,                    MSG_VOL_SUB,                            MSG_NONE        },      //SW2   
                      {MSG_PLAY_PAUSE,        MSG_BLUETOOTH_REJECT,   MSG_BLUETOOTH_REJECT,           MSG_NONE        },      //SW4
                      {MSG_TREBUP,            MSG_TREBUP,                             MSG_TREBUP,                                     MSG_NONE        },      //SW4MSG_TREBUP
                      {MSG_TREBDN,            MSG_TREBDN,                             MSG_TREBDN,                                     MSG_NONE        },      //SW4MSG_TREBUP 
                      {MSG_BASSUP,            MSG_BASSUP,                             MSG_BASSUP,                                     MSG_NONE        },      //SW4MSG_TREBUP
                      {MSG_BASSDN,            MSG_BASSDN,                             MSG_BASSDN,                                     MSG_NONE        },      //SW4MSG_TREBUP
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
                      25,     //SW7   12K             22      22      //SW17
                      30,     //SW8   16K             26      27      //SW18  
                      36,     //SW9   24K             33      33      //SW19
                      42,     //SW10  36K             39      39      //SW20
                      
              };
              #elif defined(AU6210K_LK_SJ_CSRBT)
              #define         ADC_KEY_COUNT                           4
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                                     CPR     
                      {MSG_MODE_SW,           MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW1
                      {MSG_NEXT,                      MSG_VOL_ADD,                    MSG_VOL_ADD,                            MSG_NONE        },      //SW3
                      {MSG_PRE,                       MSG_VOL_SUB,                    MSG_VOL_SUB,                            MSG_NONE        },      //SW2   
                      {MSG_PLAY_PAUSE,        MSG_BLUETOOTH_REJECT,   MSG_BLUETOOTH_REJECT,           MSG_NONE        },      //SW4
              };
              
              
              BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
              };
              
              #elif defined(AU6210K_ZB_BT007_CSR)
 221          #define         ADC_KEY_COUNT                           5
 222          static CODE BYTE AdcKeyEvent[][4] = 
 223          {
 224          //      SP                                              CPS                                     CPH                                                     CPR     
 225                  {MSG_NEXT,                      MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW3
 226                  {MSG_VOL_ADD,                   MSG_VOL_ADD,                            MSG_VOL_ADD,                                    MSG_NONE        },      //SW3
 227                  {MSG_VOL_SUB,                   MSG_VOL_SUB,                            MSG_VOL_SUB,                                    MSG_NONE        },      //SW4
 228                  {MSG_PRE,                       MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW2   
 229                  {MSG_PLAY_PAUSE,        MSG_MODE_SW,                    MSG_NONE,                                       MSG_NONE        },      //SW4
 230          };
 231          
 232          
 233          BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
 234          { 
 235                  3,      //SW3   0               0       0       //SW13
 236                  9,      //SW4   2.2k            6       6       //SW14
 237                  14,     //SW5   4.7K            11      12      //SW15
 238                  19,     //SW6   7.5K            16      17      //SW16
 239                  25,     //SW7   12K             22      22      //SW17
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 5   

 240                  
 241          };
 242          #else
              #define         ADC_KEY_COUNT                           11
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR
              #ifdef FUNC_LED_ADC1_KEY_MULTIPLE_EN    
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW1   
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW2   
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW3
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                }, //SW4
                      {MSG_PLAY_PAUSE,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW5
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW6
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW7
                      {MSG_MODE_SW,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW8
                      {MSG_EQ_SW,             MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW11
                      {MSG_VOL_ADD,           MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW12
                      {MSG_VOL_SUB,           MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW24
              #else
                      {MSG_PLAY_PAUSE,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW1   
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW2   
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW3
                      {MSG_MODE_SW,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                }, //SW4
                      {MSG_EQ_SW,             MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW5
                      {MSG_VOL_SUB,           MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW6
                      {MSG_VOL_ADD,           MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW7
                      {MSG_REPEAT,            MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW8
                      {MSG_MUTE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW11
                      {MSG_NEXT1,             MSG_10TRACK_ADD,        MSG_10TRACK_ADDCP,      MSG_NONE                },      //SW12
                      {MSG_PREV1,             MSG_10TRACK_SUB,        MSG_10TRACK_SUBCP,      MSG_NONE                },      //SW24
              #endif
              
              #ifdef FUNC_LED_ADC2_KEY_MULTIPLE_EN            
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW13  
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW14
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW15
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW16  
                      {MSG_NEXT,                      MSG_FF_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW17
                      {MSG_PRE,                       MSG_FB_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW18
                      {MSG_NEXT_FOLDER,       MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW19
                      {MSG_PRE_FOLDER,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW20
                      {MSG_NEXT1,             MSG_10TRACK_ADD,        MSG_10TRACK_ADDCP,      MSG_NONE                },      //SW21
                      {MSG_PREV1,             MSG_10TRACK_SUB,        MSG_10TRACK_SUBCP,      MSG_NONE                },      //SW22
                      {MSG_MUTE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW25
              #else
                      {MSG_NEXT,                      MSG_FF_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW13  
                      {MSG_PRE,                       MSG_FB_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW14
                      {MSG_NEXT_FOLDER,       MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW15
                      {MSG_PRE_FOLDER,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW16  
                      {MSG_FOLDER_EN,         MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW17
                      {MSG_MODE_USB,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW18
                      {MSG_MODE_SD,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW19
                      {MSG_MODE_FM,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW20
                      {MSG_MODE_AUX,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW21
                      {MSG_MODE_MP3,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW22
                      {MSG_UPDATE_FLASH,      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW25
              #endif
              };
              
              #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              //上拉电阻100k
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 6   

              BYTE CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   12k (0.35v)     6       7       //SW14
                      14,     //SW5   20k(0.55v)      10      11      //SW15
                      19,     //SW6   33k(0.81v)      15      16      //SW16 
                      23,     //SW7   47k(1.05v)      20      21      //SW17
                      28,     //SW8   68k(1.33v)      25      26      //SW18  
                      32,     //SW9   91k(1.58v)      30      31      //SW19
                      38,     //SW10  120k(1.80v)     34      35      //SW20
                      43,     //SW11  180k(2.12v)     41      41      //SW21
                      48,     //SW12  240k(2.33v)     45      45      //SW22
                      54      //SW24  390k(2.63v)     50      51      //SW25
              };
              #else
              //上拉电阻22k
              BYTE CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
                      25,     //SW7   12K             22      22      //SW17
                      30,     //SW8   16K             26      27      //SW18  
                      36,     //SW9   24K             33      33      //SW19
                      42,     //SW10  36K             39      39      //SW20
                      47,     //SW11  51K             44      44      //SW21
                      54,     //SW12  91K             51      51      //SW22
                      60      //SW24  220K            57      58      //SW25
              };
              #endif
              #endif
 334          
 335          #ifdef HEADPHONE_ADC_PORT_CH
              #ifdef HEADPHONE_ADC_PU_EN
              //上拉电阻[拔出耳机3.3v，插上耳机1.6v]
              BYTE CODE KeyVal2[2] = 
              { 
                      50,     //SW1   32
                      66      //SW2   64
              };
              #else
              //下拉电阻[拔出耳机0v，插上耳机1.6v]
              BYTE CODE KeyVal2[2] = 
              { 
                      15,     //SW1   0       
                      50      //SW2   32
              };
              #endif
              #endif
 352          
 353          
 354          // Key process, image key value to key event.
 355          static BYTE     AdcChannelKeyGet(BYTE Channel)                                                  
 356          {
 357   1              BYTE Val;
 358   1              BYTE KeyIndex;
 359   1              BYTE KeyCount;
 360   1      
 361   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
                      Val = AdcReadOneChannel(Channel, ADC_VREF_AVDD33);
              #else
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 7   

 364   1              Val = (AdcReadOneChannel(Channel, ADC_VREF_AVDD33)
 365   1                   + AdcReadOneChannel(Channel, ADC_VREF_AVDD33) 
 366   1                       + AdcReadOneChannel(Channel, ADC_VREF_AVDD33) + 2) / 3;        
 367   1      #endif
 368   1      
 369   1      #ifdef HEADPHONE_ADC_PORT_CH
                      if(Channel == HEADPHONE_ADC_PORT_CH)
                      {
                              KeyCount = 2;
                      }
                      else
              #endif
 376   1              {
 377   2                      KeyCount = ADC_KEY_COUNT;
 378   2              }
 379   1      
 380   1              for(KeyIndex = 0; KeyIndex < KeyCount; KeyIndex++)
 381   1              {
 382   2      #ifdef HEADPHONE_ADC_PORT_CH
                              if(Channel == HEADPHONE_ADC_PORT_CH)
                              {
                                      if(Val < KeyVal2[KeyIndex])
                                      {
                                              return KeyIndex;        
                                      }
                              }
                              else
              #endif
 392   2                      {
 393   3                              if(Val < KeyVal1[KeyIndex])
 394   3                              {
 395   4      
 396   4      
 397   4      #ifdef CSR_IO_CTRL
 398   4                                      DBG1(("22222222"));
 399   4                                      DBG1(("22222222aaaaaKeyIndex = %d",KeyIndex));
 400   4                                      if(gSys.SystemMode == SYS_MODE_BLUETOOTH )
 401   4                                      {                               
 402   5                                              switch(KeyIndex)
 403   5                                              {
 404   6                                              case 0:
 405   6                                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x04; //A2
 406   6                                                      break;
 407   6                                              case 1: 
 408   6                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x04; //D2
 409   6                                                      break;
 410   6                                              case 2:
 411   6                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x40; //D6
 412   6                                                      break;
 413   6                                              case 3:
 414   6                                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x02; //A1
 415   6                                                      break;
 416   6                                              case 4:
 417   6                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x10; //D4
 418   6                                                      break;
 419   6                                              default:
 420   6                                                      break;
 421   6                                              }
 422   5                                      }
 423   4      
 424   4      #endif
 425   4                              
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 8   

 426   4                              
 427   4                                      //DBG(("AdcKeyIndex:%bd\n", KeyIndex));
 428   4                                      return KeyIndex;        
 429   4                              }
 430   3                      }
 431   2              }       
 432   1              
 433   1              return -1;
 434   1      }
 435          
 436          
 437          static BYTE GetAdcKeyIndex(VOID)
 438          {
 439   1              BYTE KeyIndex;
 440   1              
 441   1              KeyIndex = -1;  
 442   1              
 443   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
                      //段码LED屏与ADC复用示例
              #if (defined(FUNC_7PIN_SEG_LED_EN) || defined(FUNC_6PIN_SEG_LED_EN))
                      gLedDispRefreshFlag = FALSE;    
                      LedPinGpioInit();
              #endif
              
                      //切回ADC 口
              #ifdef FUNC_LED_ADC1_KEY_MULTIPLE_EN    
                      baGPIOCtrl[LED_ADC1_KEY_MULTIPLE_PORT_PU] &= ~LED_ADC1_KEY_MULTIPLE_BIT;
                      baGPIOCtrl[LED_ADC1_KEY_MULTIPLE_PORT_PD] |= LED_ADC1_KEY_MULTIPLE_BIT;         
              #endif
              
              #ifdef FUNC_LED_ADC2_KEY_MULTIPLE_EN
                      baGPIOCtrl[LED_ADC2_KEY_MULTIPLE_PORT_PU] &= ~LED_ADC2_KEY_MULTIPLE_BIT;
                      baGPIOCtrl[LED_ADC2_KEY_MULTIPLE_PORT_PD] |= LED_ADC2_KEY_MULTIPLE_BIT;
              #endif
              
                      WaitUs(40); //复用时确保AD端口稳定
              #endif
 463   1      
 464   1      #ifdef ADC_KEY_PORT_CH1
 465   1              KeyIndex = AdcChannelKeyGet(ADC_KEY_PORT_CH1);
 466   1      #endif
 467   1      
 468   1      #ifdef ADC_KEY_PORT_CH2
                      if(KeyIndex == -1)
                      {
                              KeyIndex = AdcChannelKeyGet(ADC_KEY_PORT_CH2);
                              if(KeyIndex != -1)
                              {
                                      KeyIndex += ADC_KEY_COUNT;
                              }
                      }
              #endif
 478   1      
 479   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              #if (defined(FUNC_7PIN_SEG_LED_EN) || defined(FUNC_6PIN_SEG_LED_EN))
                      gLedDispRefreshFlag = TRUE; 
              #endif
              #endif
 484   1      
 485   1      #ifdef HEADPHONE_ADC_PORT_CH
                      if(KeyIndex == -1)
                      {
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 9   

                              KeyIndex = AdcChannelKeyGet(HEADPHONE_ADC_PORT_CH);
                              if(KeyIndex != -1)
                              {
                                      KeyIndex += 22;
                              }
                      }       
              #endif
 495   1      
 496   1              return KeyIndex;
 497   1      }
 498          
 499          
 500          // Initialize hardware key scan (GPIO) operation.
 501          VOID AdcKeyScanInit(VOID)
 502          {
 503   1              AdcKeyState = ADC_KEY_STATE_IDLE;
 504   1              TimeOutSet(&AdcKeyScanTimer, 0);
 505   1              
 506   1      #ifdef AU6210K_NR_D_8_CSRBT
                      SET_B6_ANALOG_IN(); 
              #endif
 509   1      
 510   1      #ifdef ADC_KEY_PORT_CH1
 511   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN(); 
              #endif
 514   1      
 515   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_D7) 
 516   1              SET_D7_ANALOG_IN();
 517   1      #endif
 518   1      
 519   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
 522   1      
 523   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
 526   1      #endif
 527   1      
 528   1      #ifdef ADC_KEY_PORT_CH2
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_D7)
                      SET_D7_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
              #endif
 545   1      
 546   1      #ifdef HEADPHONE_ADC_PORT_CH
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN();
              #endif
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 10  

                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_D7)
                      SET_D7_ANALOG_IN();
              #endif
                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
              #endif
 563   1      
 564   1      #ifdef CSR_IO_CTRL
 565   1              baGPIOCtrl[GPIO_D_IE] &= ~0x04;//D2
 566   1              baGPIOCtrl[GPIO_D_OE] |= 0x04;
 567   1              baGPIOCtrl[GPIO_D_PU] |= 0x04;
 568   1              baGPIOCtrl[GPIO_D_PD] |= 0x04; 
 569   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x04; 
 570   1              WaitMs(2);
 571   1      
 572   1              baGPIOCtrl[GPIO_D_IE] &= ~0x10;//D4
 573   1              baGPIOCtrl[GPIO_D_OE] |= 0x10;
 574   1              baGPIOCtrl[GPIO_D_PU] |= 0x10;
 575   1              baGPIOCtrl[GPIO_D_PD] |= 0x10; 
 576   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x10; 
 577   1              WaitMs(2);
 578   1              
 579   1              baGPIOCtrl[GPIO_D_IE] &= ~0x40;//D6
 580   1              baGPIOCtrl[GPIO_D_OE] |= 0x40;
 581   1              baGPIOCtrl[GPIO_D_PU] |= 0x40;
 582   1              baGPIOCtrl[GPIO_D_PD] |= 0x40; 
 583   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x40; 
 584   1              WaitMs(2);
 585   1              
 586   1              baGPIOCtrl[GPIO_A_IE] &= ~0x02;//A1
 587   1              baGPIOCtrl[GPIO_A_OE] |= 0x02;
 588   1              baGPIOCtrl[GPIO_A_PU] |= 0x02;
 589   1              baGPIOCtrl[GPIO_A_PD] |= 0x02; 
 590   1              baGPIOCtrl[GPIO_A_OUT] &= ~0x02; 
 591   1              WaitMs(2);
 592   1              
 593   1              baGPIOCtrl[GPIO_A_IE] &= ~0x04;//A2
 594   1              baGPIOCtrl[GPIO_A_OE] |= 0x04;
 595   1              baGPIOCtrl[GPIO_A_PU] |= 0x04;
 596   1              baGPIOCtrl[GPIO_A_PD] |= 0x04; 
 597   1              baGPIOCtrl[GPIO_A_OUT] &= ~0x04; 
 598   1              WaitMs(2);
 599   1              DBG1(("dfdfd"));
 600   1      #endif
 601   1      }
 602          
 603          
 604          // Key process, image key value to key event.
 605          MESSAGE AdcKeyEventGet(VOID)                                                    
 606          {
 607   1              static  BYTE PreKeyIndex = -1;
 608   1              static  BYTE KeyIndex;
 609   1      
 610   1              //DBG(("AdcKeyEventGet*******\n"));
 611   1              if(!IsTimeOut(&AdcKeyScanTimer))
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 11  

 612   1              {
 613   2                      return MSG_NONE;
 614   2              }
 615   1              TimeOutSet(&AdcKeyScanTimer, ADC_KEY_SCAN_TIME);        
 616   1      
 617   1              KeyIndex = GetAdcKeyIndex();
 618   1      
 619   1      #ifdef FUNC_BEEP_SOUND_EN       
                      gPushKeyNeedBeepFlag = FALSE;
              #endif
 622   1      
 623   1              switch(AdcKeyState)
 624   1              {
 625   2                      case ADC_KEY_STATE_IDLE:
 626   2                              if(KeyIndex == -1)
 627   2                              {
 628   3      #ifdef CSR_IO_CTRL
 629   3                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x20;        //D5
 630   3                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x40;        //D6
 631   3                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x04;        //A2
 632   3                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x02;        //A1
 633   3      #endif                          
 634   3                                      return MSG_NONE;
 635   3                              }
 636   2      
 637   2                              PreKeyIndex = KeyIndex;
 638   2                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_JTTER_TIME);
 639   2                              //DBG(("GOTO JITTER!\n"));
 640   2                              AdcKeyState = ADC_KEY_STATE_JITTER;
 641   2                                      
 642   2                      case ADC_KEY_STATE_JITTER:
 643   2                              if(PreKeyIndex != KeyIndex)
 644   2                              {
 645   3                                      //DBG(("%bx != %bx,GOTO IDLE Because jitter!\n", PreKeyIndex, KeyIndex));
 646   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;
 647   3                              }
 648   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 649   2                              {
 650   3                                      //DBG(("GOTO PRESS_DOWN!\n"));
 651   3      //                              if((PreKeyIndex == ADC_KEY_POWER0_IDX)  
 652   3      //                              ||(PreKeyIndex == ADC_KEY_POWER1_IDX)
 653   3      //                              || (PreKeyIndex == ADC_KEY_POWER2_IDX)                          
 654   3      //                              )
 655   3      //                              {        
 656   3      //                                      //set cp-time 3000ms for power-down key 
 657   3      //                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_PWRDOWN_CP_TIME);  
 658   3      //                              }       
 659   3      
 660   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_HPPUSHOUT_CP_TIME);
                                              }
                                              else
              #endif                          
 667   3                                      {
 668   4                                              //DBG(("ADC_KEY_CP_TIME!\n"));
 669   4                                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CP_TIME);
 670   4                                      }
 671   3                                      AdcKeyState = ADC_KEY_STATE_PRESS_DOWN;
 672   3                              }
 673   2                              break;
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 12  

 674   2      
 675   2                      case ADC_KEY_STATE_PRESS_DOWN:
 676   2                              if(PreKeyIndex != KeyIndex)
 677   2                              {
 678   3                                      //return key sp value
 679   3                                      //DBG(("KEY  SP  %bu\n",PreKeyIndex));
 680   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;
 681   3      #ifdef FUNC_BEEP_SOUND_EN       
                                              gPushKeyNeedBeepFlag = TRUE;
              #endif
 684   3      
 685   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if((PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) || (PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX))
                                              {
                                                      break;
                                              }
              #endif
 691   3      
 692   3      #ifdef CSR_IO_CTRL
 693   3                                      if(gSys.SystemMode == SYS_MODE_BLUETOOTH )
 694   3                                      {
 695   4      
 696   4                                              switch(PreKeyIndex)
 697   4                                              {
 698   5                                              case 0:
 699   5                                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x04; //A2
 700   5                                                      break;
 701   5                                              case 1: 
 702   5                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x04; //D2
 703   5                                                      break;
 704   5                                              case 2:
 705   5                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x40; //D6
 706   5                                                      break;
 707   5                                              case 3:
 708   5                                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x02; //A1
 709   5                                                      break;
 710   5                                              case 4:
 711   5                                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x10; //D4
 712   5                                                      break;
 713   5                                              default:
 714   5                                                      break;
 715   5                                              }
 716   4                                      }
 717   3      
 718   3      #endif
 719   3      
 720   3                                      return AdcKeyEvent[PreKeyIndex][0];
 721   3                              }
 722   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 723   2                              {
 724   3                                      //return key cp value
 725   3                                      //DBG(("KEY CPS  %bu\n",PreKeyIndex));
 726   3                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CPH_TIME);
 727   3                                      AdcKeyState = ADC_KEY_STATE_CP;
 728   3      #ifdef FUNC_BEEP_SOUND_EN       
                                              gPushKeyNeedBeepFlag = TRUE;
              #endif
 731   3      
 732   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) 
                                              {                                       
                                                      break;
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 13  

                                              }
                                              if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = FALSE;
                                                      break;
                                              }
              #endif
 743   3                                      return AdcKeyEvent[PreKeyIndex][1];
 744   3                              }
 745   2                              break;
 746   2      
 747   2                      case ADC_KEY_STATE_CP:
 748   2                              if(PreKeyIndex != KeyIndex)
 749   2                              {
 750   3                                      //return key cp value
 751   3                                      //DBG(("ADC KEY CPR!\n"));
 752   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;                               
 753   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if((PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) || (PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX))
                                              {
                                                      break;
                                              }
              #endif
 759   3                                      return AdcKeyEvent[PreKeyIndex][3];
 760   3                              }
 761   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 762   2                              {
 763   3                                      //return key cph value
 764   3                                      //DBG(("ADC KEY CPH!\n"));
 765   3      //                              if((PreKeyIndex == ADC_KEY_POWER0_IDX)  
 766   3      //                              ||(PreKeyIndex == ADC_KEY_POWER1_IDX)
 767   3      //                              || (PreKeyIndex == ADC_KEY_POWER2_IDX))
 768   3      //                              {        
 769   3      //                                      //set cp-time 3000ms for power-down key 
 770   3      //                                      //DBG(("ADC POWER!\n"));
 771   3      //                                      TimeOutSet(&AdcKeyWaitTimer, 3000);
 772   3      //                              }
 773   3      //                              else
 774   3      //                              {
 775   3                                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CPH_TIME);
 776   3      //                              }
 777   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHIN_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = TRUE;
                                                      break;
                                              }
                                              else if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = FALSE;
                                                      break;
                                              }
              #endif
 789   3                                      return AdcKeyEvent[PreKeyIndex][2];
 790   3                              }
 791   2                              break;
 792   2      
 793   2                      default:
 794   2                              AdcKeyState = ADC_KEY_STATE_IDLE;
 795   2                              break;
 796   2              }
 797   1              return MSG_NONE;
C51 COMPILER V9.00   ADC_KEY                                                               11/14/2015 16:49:46 PAGE 14  

 798   1      }
 799          
 800          
 801          #else
                      #warning        "MV: ADC KEY NOT ENABLE!"
                      
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    911    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =     13       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
