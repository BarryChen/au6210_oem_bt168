C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADC_KEY
OBJECT MODULE PLACED IN .\output\obj\adc_key.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE key\adc_key.c LARGE OBJECTADVANCED OPTIMIZE(9,SIZE) BROWSE INCDIR(.\config;
                    -.\device;.\display;.\fs;.\key;.\lib_if;.\play;.\system;.\library;.\power;.\radio;.\eeprom;.\spi_flash;.\slave;.\bluetoot
                    -h;.\i2c) DEBUG PRINT(.\output\lst\adc_key.lst) OBJECT(.\output\obj\adc_key.obj)

line level    source

   1          #include <reg51.h>                                                                              //include public header files
   2          
   3          #include "type.h"                                                                               //include project header files
   4          #include "syscfg.h"
   5          #include "utility.h"
   6          #include "debug.h"
   7          #include "timer.h"
   8          #include "sysctrl.h"
   9          #include "key.h"
  10          #include "adc_key.h"
  11          #include "gpio.h"
  12          #include "adc.h"
  13          #include "message.h"
  14          #include "device.h"
  15          #include "seg_panel.h"
  16          #include "seg_led_disp.h"
  17          
  18          
  19          #ifdef FUNC_ADC_KEY_EN
  20          
  21          #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              #define         ADC_KEY_SCAN_TIME                       20
              #define         ADC_KEY_JTTER_TIME                      40
              #else
  25          #define         ADC_KEY_SCAN_TIME                       10
  26          #define         ADC_KEY_JTTER_TIME                      20
  27          #endif
  28          #define         ADC_KEY_CP_TIME                         600     //1000
  29          #define         ADC_KEY_PWRDOWN_CP_TIME         2000    //cp-time for power-down key
  30          #define         ADC_KEY_CPH_TIME                        200             //450
  31          #define         ADC_KEY_HPPUSHOUT_CP_TIME       200
  32          
  33          //#define               ADC_KEY_COUNT                           11
  34          
  35          #define         ADC_KEY_POWER0_IDX                      8               //POWER-DOWN KEY index.
  36          #define         ADC_KEY_POWER1_IDX                      15              //POWER-DOWN KEY index.
  37          #define         ADC_KEY_POWER2_IDX                      20
  38          
  39          #ifdef HEADPHONE_ADC_PORT_CH
              #ifdef HEADPHONE_ADC_PU_EN
              #define         ADC_KEY_HPPUSHOUT_IDX           23
              #define         ADC_KEY_HPPUSHIN_IDX            22
              #else
              #define         ADC_KEY_HPPUSHOUT_IDX           22
              #define         ADC_KEY_HPPUSHIN_IDX            23
              #endif
              #endif
  48          
  49          typedef enum _ADC_KEY_STATE
  50          {
  51                  ADC_KEY_STATE_IDLE,
  52                  ADC_KEY_STATE_JITTER,
  53                  ADC_KEY_STATE_PRESS_DOWN,
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 2   

  54                  ADC_KEY_STATE_CP
  55          
  56          } ADC_KEY_STATE;
  57          
  58          TIMER                   AdcKeyWaitTimer;
  59          TIMER                   AdcKeyScanTimer;
  60          ADC_KEY_STATE   AdcKeyState;
  61          
  62          
  63          #ifdef FUNC_BEEP_SOUND_EN       
              extern BOOL gPushKeyNeedBeepFlag;
              #endif
  66          
  67          #ifdef FUNC_SEG_LED_EN
              extern BOOL gLedDispRefreshFlag;
              #endif
  70          
  71          #if defined(AU6210K_ZB_BT007_CSR)
  72          #define         ADC_KEY_COUNT                           5
  73          static CODE BYTE AdcKeyEvent[][4] = 
  74          {
  75          //      SP                                              CPS                                     CPH                                                     CPR     
  76                  {MSG_PLAY_PAUSE,        MSG_MODE_SW,                    MSG_NONE,                                       MSG_NONE        },      //SW4
  77                  {MSG_NEXT,                      MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW3
  78                  {MSG_PRE,                       MSG_NONE,                               MSG_NONE,                                       MSG_NONE        },      //SW2   
  79                  {MSG_VOL_ADD,                   MSG_VOL_ADD,                            MSG_VOL_ADD,                                    MSG_NONE        },      //SW3
  80                  {MSG_VOL_SUB,                   MSG_VOL_SUB,                            MSG_VOL_SUB,                                    MSG_NONE        },      //SW4
  81          };
  82          
  83          
  84          BYTE  CODE KeyVal1[ADC_KEY_COUNT] = 
  85          { 
  86                  9,      //SW4   2.2k            6       6       //SW14
  87                  14,     //SW5   4.7K            11      12      //SW15
  88                  19,     //SW6   7.5K            16      17      //SW16
  89                  25,     //SW7   12K             22      22      //SW17
  90                  36,     //SW9   24K             33      33      //SW19
  91                  
  92          };
  93          #else
              #define         ADC_KEY_COUNT                           11
              static CODE BYTE AdcKeyEvent[][4] = 
              {
              //      SP                                              CPS                                     CPH                                     CPR
              #ifdef FUNC_LED_ADC1_KEY_MULTIPLE_EN    
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW1   
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW2   
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW3
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                }, //SW4
                      {MSG_PLAY_PAUSE,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW5
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW6
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW7
                      {MSG_MODE_SW,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW8
                      {MSG_EQ_SW,             MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW11
                      {MSG_VOL_ADD,           MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW12
                      {MSG_VOL_SUB,           MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW24
              #else
                      {MSG_PLAY_PAUSE,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW1   
                      {MSG_NEXT,                      MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW2   
                      {MSG_PRE,                       MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW3
                      {MSG_MODE_SW,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                }, //SW4
                      {MSG_EQ_SW,             MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW5
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 3   

                      {MSG_VOL_SUB,           MSG_VOL_SUB,            MSG_VOL_SUB,            MSG_NONE                },      //SW6
                      {MSG_VOL_ADD,           MSG_VOL_ADD,            MSG_VOL_ADD,            MSG_NONE                },      //SW7
                      {MSG_REPEAT,            MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW8
                      {MSG_MUTE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW11
                      {MSG_NEXT1,             MSG_10TRACK_ADD,        MSG_10TRACK_ADDCP,      MSG_NONE                },      //SW12
                      {MSG_PREV1,             MSG_10TRACK_SUB,        MSG_10TRACK_SUBCP,      MSG_NONE                },      //SW24
              #endif
              
              #ifdef FUNC_LED_ADC2_KEY_MULTIPLE_EN            
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW13  
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW14
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW15
                      {MSG_NONE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW16  
                      {MSG_NEXT,                      MSG_FF_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW17
                      {MSG_PRE,                       MSG_FB_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW18
                      {MSG_NEXT_FOLDER,       MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW19
                      {MSG_PRE_FOLDER,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW20
                      {MSG_NEXT1,             MSG_10TRACK_ADD,        MSG_10TRACK_ADDCP,      MSG_NONE                },      //SW21
                      {MSG_PREV1,             MSG_10TRACK_SUB,        MSG_10TRACK_SUBCP,      MSG_NONE                },      //SW22
                      {MSG_MUTE,                      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW25
              #else
                      {MSG_NEXT,                      MSG_FF_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW13  
                      {MSG_PRE,                       MSG_FB_START,           MSG_NONE,                       MSG_FF_FB_END   },      //SW14
                      {MSG_NEXT_FOLDER,       MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW15
                      {MSG_PRE_FOLDER,        MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW16  
                      {MSG_FOLDER_EN,         MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW17
                      {MSG_MODE_USB,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW18
                      {MSG_MODE_SD,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW19
                      {MSG_MODE_FM,           MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW20
                      {MSG_MODE_AUX,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW21
                      {MSG_MODE_MP3,          MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW22
                      {MSG_UPDATE_FLASH,      MSG_NONE,                       MSG_NONE,                       MSG_NONE                },      //SW25
              #endif
              };
              
              #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              //上拉电阻100k
              BYTE CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   12k (0.35v)     6       7       //SW14
                      14,     //SW5   20k(0.55v)      10      11      //SW15
                      19,     //SW6   33k(0.81v)      15      16      //SW16 
                      23,     //SW7   47k(1.05v)      20      21      //SW17
                      28,     //SW8   68k(1.33v)      25      26      //SW18  
                      32,     //SW9   91k(1.58v)      30      31      //SW19
                      38,     //SW10  120k(1.80v)     34      35      //SW20
                      43,     //SW11  180k(2.12v)     41      41      //SW21
                      48,     //SW12  240k(2.33v)     45      45      //SW22
                      54      //SW24  390k(2.63v)     50      51      //SW25
              };
              #else
              //上拉电阻22k
              BYTE CODE KeyVal1[ADC_KEY_COUNT] = 
              { 
                      3,      //SW3   0               0       0       //SW13
                      9,      //SW4   2.2k            6       6       //SW14
                      14,     //SW5   4.7K            11      12      //SW15
                      19,     //SW6   7.5K            16      17      //SW16
                      25,     //SW7   12K             22      22      //SW17
                      30,     //SW8   16K             26      27      //SW18  
                      36,     //SW9   24K             33      33      //SW19
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 4   

                      42,     //SW10  36K             39      39      //SW20
                      47,     //SW11  51K             44      44      //SW21
                      54,     //SW12  91K             51      51      //SW22
                      60      //SW24  220K            57      58      //SW25
              };
              #endif
              #endif
 185          
 186          #ifdef HEADPHONE_ADC_PORT_CH
              #ifdef HEADPHONE_ADC_PU_EN
              //上拉电阻[拔出耳机3.3v，插上耳机1.6v]
              BYTE CODE KeyVal2[2] = 
              { 
                      50,     //SW1   32
                      66      //SW2   64
              };
              #else
              //下拉电阻[拔出耳机0v，插上耳机1.6v]
              BYTE CODE KeyVal2[2] = 
              { 
                      15,     //SW1   0       
                      50      //SW2   32
              };
              #endif
              #endif
 203          
 204          
 205          // Key process, image key value to key event.
 206          static BYTE     AdcChannelKeyGet(BYTE Channel)                                                  
 207          {
 208   1              BYTE Val;
 209   1              BYTE KeyIndex;
 210   1              BYTE KeyCount;
 211   1      
 212   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
                      Val = AdcReadOneChannel(Channel, ADC_VREF_AVDD33);
              #else
 215   1              Val = (AdcReadOneChannel(Channel, ADC_VREF_AVDD33)
 216   1                   + AdcReadOneChannel(Channel, ADC_VREF_AVDD33) 
 217   1                       + AdcReadOneChannel(Channel, ADC_VREF_AVDD33) + 2) / 3;        
 218   1      #endif
 219   1      
 220   1      #ifdef HEADPHONE_ADC_PORT_CH
                      if(Channel == HEADPHONE_ADC_PORT_CH)
                      {
                              KeyCount = 2;
                      }
                      else
              #endif
 227   1              {
 228   2                      KeyCount = ADC_KEY_COUNT;
 229   2              }
 230   1      
 231   1              for(KeyIndex = 0; KeyIndex < KeyCount; KeyIndex++)
 232   1              {
 233   2      #ifdef HEADPHONE_ADC_PORT_CH
                              if(Channel == HEADPHONE_ADC_PORT_CH)
                              {
                                      if(Val < KeyVal2[KeyIndex])
                                      {
                                              return KeyIndex;        
                                      }
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 5   

                              }
                              else
              #endif
 243   2                      {
 244   3                              if(Val < KeyVal1[KeyIndex])
 245   3                              {
 246   4      
 247   4      
 248   4      #ifdef CSR_IO_CTRL
 249   4                                      DBG1(("22222222"));
 250   4                                      DBG1(("22222222aaaaaKeyIndex = %d",KeyIndex));
 251   4                                      if(gSys.SystemMode == SYS_MODE_BLUETOOTH )
 252   4                                      {                               
 253   5                                              switch(KeyIndex)
 254   5                                              {
 255   6                                              case 0:
 256   6                                                      baGPIOCtrl[GPIO_A_OUT] |= 0x02; //A1
 257   6                                                      break;
 258   6                                              case 1: 
 259   6                                                      baGPIOCtrl[GPIO_A_OUT] |= 0x04; //A2
 260   6                                                      break;
 261   6                                              case 2:
 262   6                                                      baGPIOCtrl[GPIO_D_OUT] |= 0x04; //D2
 263   6                                                      break;
 264   6                                              
 265   6                                              default:
 266   6                                                      break;
 267   6                                              }
 268   5                                      }
 269   4      
 270   4      #endif
 271   4                              
 272   4                              
 273   4                                      //DBG(("AdcKeyIndex:%bd\n", KeyIndex));
 274   4                                      return KeyIndex;        
 275   4                              }
 276   3                      }
 277   2              }       
 278   1              
 279   1              return -1;
 280   1      }
 281          
 282          
 283          static BYTE GetAdcKeyIndex(VOID)
 284          {
 285   1              BYTE KeyIndex;
 286   1              
 287   1              KeyIndex = -1;  
 288   1              
 289   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
                      //段码LED屏与ADC复用示例
              #if (defined(FUNC_7PIN_SEG_LED_EN) || defined(FUNC_6PIN_SEG_LED_EN))
                      gLedDispRefreshFlag = FALSE;    
                      LedPinGpioInit();
              #endif
              
                      //切回ADC 口
              #ifdef FUNC_LED_ADC1_KEY_MULTIPLE_EN    
                      baGPIOCtrl[LED_ADC1_KEY_MULTIPLE_PORT_PU] &= ~LED_ADC1_KEY_MULTIPLE_BIT;
                      baGPIOCtrl[LED_ADC1_KEY_MULTIPLE_PORT_PD] |= LED_ADC1_KEY_MULTIPLE_BIT;         
              #endif
              
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 6   

              #ifdef FUNC_LED_ADC2_KEY_MULTIPLE_EN
                      baGPIOCtrl[LED_ADC2_KEY_MULTIPLE_PORT_PU] &= ~LED_ADC2_KEY_MULTIPLE_BIT;
                      baGPIOCtrl[LED_ADC2_KEY_MULTIPLE_PORT_PD] |= LED_ADC2_KEY_MULTIPLE_BIT;
              #endif
              
                      WaitUs(40); //复用时确保AD端口稳定
              #endif
 309   1      
 310   1      #ifdef ADC_KEY_PORT_CH1
 311   1              KeyIndex = AdcChannelKeyGet(ADC_KEY_PORT_CH1);
 312   1      #endif
 313   1      
 314   1      #ifdef ADC_KEY_PORT_CH2
                      if(KeyIndex == -1)
                      {
                              KeyIndex = AdcChannelKeyGet(ADC_KEY_PORT_CH2);
                              if(KeyIndex != -1)
                              {
                                      KeyIndex += ADC_KEY_COUNT;
                              }
                      }
              #endif
 324   1      
 325   1      #if (defined(FUNC_LED_ADC1_KEY_MULTIPLE_EN) || defined(FUNC_LED_ADC2_KEY_MULTIPLE_EN))
              #if (defined(FUNC_7PIN_SEG_LED_EN) || defined(FUNC_6PIN_SEG_LED_EN))
                      gLedDispRefreshFlag = TRUE; 
              #endif
              #endif
 330   1      
 331   1      #ifdef HEADPHONE_ADC_PORT_CH
                      if(KeyIndex == -1)
                      {
                              KeyIndex = AdcChannelKeyGet(HEADPHONE_ADC_PORT_CH);
                              if(KeyIndex != -1)
                              {
                                      KeyIndex += 22;
                              }
                      }       
              #endif
 341   1      
 342   1              return KeyIndex;
 343   1      }
 344          
 345          
 346          // Initialize hardware key scan (GPIO) operation.
 347          VOID AdcKeyScanInit(VOID)
 348          {
 349   1              AdcKeyState = ADC_KEY_STATE_IDLE;
 350   1              TimeOutSet(&AdcKeyScanTimer, 0);
 351   1              
 352   1      #ifdef AU6210K_NR_D_8_CSRBT
                      SET_B6_ANALOG_IN(); 
              #endif
 355   1      
 356   1      #ifdef ADC_KEY_PORT_CH1
 357   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN(); 
              #endif
 360   1      
 361   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_D7) 
 362   1              SET_D7_ANALOG_IN();
 363   1      #endif
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 7   

 364   1      
 365   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
 368   1      
 369   1      #if (ADC_KEY_PORT_CH1 == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
 372   1      #endif
 373   1      
 374   1      #ifdef ADC_KEY_PORT_CH2
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_D7)
                      SET_D7_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
              
              #if (ADC_KEY_PORT_CH2 == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
              #endif
 391   1      
 392   1      #ifdef HEADPHONE_ADC_PORT_CH
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_B6)
                      SET_B6_ANALOG_IN();
              #endif
                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_D7)
                      SET_D7_ANALOG_IN();
              #endif
                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_E0)
                      SET_E0_ANALOG_IN();
              #endif
                      
              #if (HEADPHONE_ADC_PORT_CH == ADC_CHANNEL_E1)
                      SET_E1_ANALOG_IN();
              #endif
              #endif
 409   1      
 410   1      #ifdef CSR_IO_CTRL
 411   1      //mini503:  D6接听电话按键 复合power按键 
 412   1              baGPIOCtrl[GPIO_D_IE] &= ~0x04;//D2
 413   1              baGPIOCtrl[GPIO_D_OE] |= 0x04;
 414   1              baGPIOCtrl[GPIO_D_PU] |= 0x04;
 415   1              baGPIOCtrl[GPIO_D_PD] |= 0x04; 
 416   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x04; 
 417   1              WaitMs(2);
 418   1      
 419   1              baGPIOCtrl[GPIO_D_IE] &= ~0x20;//D5
 420   1              baGPIOCtrl[GPIO_D_OE] |= 0x20;
 421   1              baGPIOCtrl[GPIO_D_PU] |= 0x20;
 422   1              baGPIOCtrl[GPIO_D_PD] |= 0x20; 
 423   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x20; 
 424   1              WaitMs(2);
 425   1              
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 8   

 426   1              baGPIOCtrl[GPIO_D_IE] &= ~0x40;//D6
 427   1              baGPIOCtrl[GPIO_D_OE] |= 0x40;
 428   1              baGPIOCtrl[GPIO_D_PU] |= 0x40;
 429   1              baGPIOCtrl[GPIO_D_PD] |= 0x40; 
 430   1              baGPIOCtrl[GPIO_D_OUT] &= ~0x40; 
 431   1              WaitMs(2);
 432   1              
 433   1              baGPIOCtrl[GPIO_A_IE] &= ~0x02;//A1
 434   1              baGPIOCtrl[GPIO_A_OE] |= 0x02;
 435   1              baGPIOCtrl[GPIO_A_PU] |= 0x02;
 436   1              baGPIOCtrl[GPIO_A_PD] |= 0x02; 
 437   1              baGPIOCtrl[GPIO_A_OUT] &= ~0x02; 
 438   1              WaitMs(2);
 439   1              
 440   1              baGPIOCtrl[GPIO_A_IE] &= ~0x04;//A2
 441   1              baGPIOCtrl[GPIO_A_OE] |= 0x04;
 442   1              baGPIOCtrl[GPIO_A_PU] |= 0x04;
 443   1              baGPIOCtrl[GPIO_A_PD] |= 0x04; 
 444   1              baGPIOCtrl[GPIO_A_OUT] &= ~0x04; 
 445   1              WaitMs(2);
 446   1      #endif
 447   1      }
 448          
 449          
 450          // Key process, image key value to key event.
 451          MESSAGE AdcKeyEventGet(VOID)                                                    
 452          {
 453   1              static  BYTE PreKeyIndex = -1;
 454   1              static  BYTE KeyIndex;
 455   1      
 456   1              //DBG(("AdcKeyEventGet*******\n"));
 457   1              if(!IsTimeOut(&AdcKeyScanTimer))
 458   1              {
 459   2                      return MSG_NONE;
 460   2              }
 461   1              TimeOutSet(&AdcKeyScanTimer, ADC_KEY_SCAN_TIME);        
 462   1      
 463   1              KeyIndex = GetAdcKeyIndex();
 464   1      
 465   1      #ifdef FUNC_BEEP_SOUND_EN       
                      gPushKeyNeedBeepFlag = FALSE;
              #endif
 468   1      
 469   1              switch(AdcKeyState)
 470   1              {
 471   2                      case ADC_KEY_STATE_IDLE:
 472   2                              if(KeyIndex == -1)
 473   2                              {
 474   3      #ifdef CSR_IO_CTRL
 475   3                                      baGPIOCtrl[GPIO_D_OUT] &= ~0x04;//D2
 476   3                              
 477   3                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x02;//A1
 478   3                                      baGPIOCtrl[GPIO_A_OUT] &= ~0x04;//A2
 479   3                                       
 480   3      #endif                          
 481   3                                      return MSG_NONE;
 482   3                              }
 483   2      
 484   2                              PreKeyIndex = KeyIndex;
 485   2                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_JTTER_TIME);
 486   2                              //DBG(("GOTO JITTER!\n"));
 487   2                              AdcKeyState = ADC_KEY_STATE_JITTER;
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 9   

 488   2                                      
 489   2                      case ADC_KEY_STATE_JITTER:
 490   2                              if(PreKeyIndex != KeyIndex)
 491   2                              {
 492   3                                      //DBG(("%bx != %bx,GOTO IDLE Because jitter!\n", PreKeyIndex, KeyIndex));
 493   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;
 494   3                              }
 495   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 496   2                              {
 497   3                                      //DBG(("GOTO PRESS_DOWN!\n"));
 498   3      //                              if((PreKeyIndex == ADC_KEY_POWER0_IDX)  
 499   3      //                              ||(PreKeyIndex == ADC_KEY_POWER1_IDX)
 500   3      //                              || (PreKeyIndex == ADC_KEY_POWER2_IDX)                          
 501   3      //                              )
 502   3      //                              {        
 503   3      //                                      //set cp-time 3000ms for power-down key 
 504   3      //                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_PWRDOWN_CP_TIME);  
 505   3      //                              }       
 506   3      
 507   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_HPPUSHOUT_CP_TIME);
                                              }
                                              else
              #endif                          
 514   3                                      {
 515   4                                              //DBG(("ADC_KEY_CP_TIME!\n"));
 516   4                                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CP_TIME);
 517   4                                      }
 518   3                                      AdcKeyState = ADC_KEY_STATE_PRESS_DOWN;
 519   3                              }
 520   2                              break;
 521   2      
 522   2                      case ADC_KEY_STATE_PRESS_DOWN:
 523   2                              if(PreKeyIndex != KeyIndex)
 524   2                              {
 525   3                                      //return key sp value
 526   3                                      //DBG(("KEY  SP  %bu\n",PreKeyIndex));
 527   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;
 528   3      #ifdef FUNC_BEEP_SOUND_EN       
                                              gPushKeyNeedBeepFlag = TRUE;
              #endif
 531   3      
 532   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if((PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) || (PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX))
                                              {
                                                      break;
                                              }
              #endif
 538   3      
 539   3      #ifdef CSR_IO_CTRL
 540   3                                      if(gSys.SystemMode == SYS_MODE_BLUETOOTH )
 541   3                                      {                               
 542   4                                              switch(KeyIndex)
 543   4                                              {
 544   5                                              case 0:
 545   5                                                      baGPIOCtrl[GPIO_A_OUT] |= 0x02; //A1
 546   5                                                      break;
 547   5                                              case 1: 
 548   5                                                      baGPIOCtrl[GPIO_A_OUT] |= 0x04; //A2
 549   5                                                      break;
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 10  

 550   5                                              case 2:
 551   5                                                      baGPIOCtrl[GPIO_D_OUT] |= 0x04; //D2
 552   5                                                      break;
 553   5                                              
 554   5                                              default:
 555   5                                                      break;
 556   5                                              }
 557   4                                      }
 558   3      
 559   3      #endif
 560   3      
 561   3                                      return AdcKeyEvent[PreKeyIndex][0];
 562   3                              }
 563   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 564   2                              {
 565   3                                      //return key cp value
 566   3                                      //DBG(("KEY CPS  %bu\n",PreKeyIndex));
 567   3                                      TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CPH_TIME);
 568   3                                      AdcKeyState = ADC_KEY_STATE_CP;
 569   3      #ifdef FUNC_BEEP_SOUND_EN       
                                              gPushKeyNeedBeepFlag = TRUE;
              #endif
 572   3      
 573   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) 
                                              {                                       
                                                      break;
                                              }
                                              if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = FALSE;
                                                      break;
                                              }
              #endif
 584   3                                      return AdcKeyEvent[PreKeyIndex][1];
 585   3                              }
 586   2                              break;
 587   2      
 588   2                      case ADC_KEY_STATE_CP:
 589   2                              if(PreKeyIndex != KeyIndex)
 590   2                              {
 591   3                                      //return key cp value
 592   3                                      //DBG(("ADC KEY CPR!\n"));
 593   3                                      AdcKeyState = ADC_KEY_STATE_IDLE;                               
 594   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if((PreKeyIndex == ADC_KEY_HPPUSHIN_IDX) || (PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX))
                                              {
                                                      break;
                                              }
              #endif
 600   3                                      return AdcKeyEvent[PreKeyIndex][3];
 601   3                              }
 602   2                              else if(IsTimeOut(&AdcKeyWaitTimer))
 603   2                              {
 604   3                                      //return key cph value
 605   3                                      //DBG(("ADC KEY CPH!\n"));
 606   3      //                              if((PreKeyIndex == ADC_KEY_POWER0_IDX)  
 607   3      //                              ||(PreKeyIndex == ADC_KEY_POWER1_IDX)
 608   3      //                              || (PreKeyIndex == ADC_KEY_POWER2_IDX))
 609   3      //                              {        
 610   3      //                                      //set cp-time 3000ms for power-down key 
 611   3      //                                      //DBG(("ADC POWER!\n"));
C51 COMPILER V9.00   ADC_KEY                                                               12/28/2015 22:10:23 PAGE 11  

 612   3      //                                      TimeOutSet(&AdcKeyWaitTimer, 3000);
 613   3      //                              }
 614   3      //                              else
 615   3      //                              {
 616   3                                              TimeOutSet(&AdcKeyWaitTimer, ADC_KEY_CPH_TIME);
 617   3      //                              }
 618   3      #ifdef HEADPHONE_ADC_PORT_CH
                                              if(PreKeyIndex == ADC_KEY_HPPUSHIN_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = TRUE;
                                                      break;
                                              }
                                              else if(PreKeyIndex == ADC_KEY_HPPUSHOUT_IDX)
                                              {
                                                      IsHeadphoneLinkFlag = FALSE;
                                                      break;
                                              }
              #endif
 630   3                                      return AdcKeyEvent[PreKeyIndex][2];
 631   3                              }
 632   2                              break;
 633   2      
 634   2                      default:
 635   2                              AdcKeyState = ADC_KEY_STATE_IDLE;
 636   2                              break;
 637   2              }
 638   1              return MSG_NONE;
 639   1      }
 640          
 641          
 642          #else
                      #warning        "MV: ADC KEY NOT ENABLE!"
                      
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    844    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =     13       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
